////////////////////////////////////////////////////////////////////////////
//
// FIFO
//
// Written By Rob F. / Entire Group ... Speccy Forever
//
////////////////////////////////////////////////////////////////////////////



UNIT RobFIFO;



INTERFACE
USES Registry, Windows, SysUtils,
     RbCRC;//, RbUtil;

TYPE tFIFO=RECORD
      WR:DWORD;
      RD:DWORD;
      SIZE:DWORD;
      MASK:DWORD;
      DAT:POINTER;
      FLAG:DWORD;
      ID:ShortString;
     END;

CONST robFIFO_ID_STR='JKASDKASNDJKASDFK';
      robFIFO_FLAG_OVERFLOW = $00000001;

FUNCTION FIFO_OPEN(VAR FI:tFIFO; SIZE:DWORD):BOOLEAN; STDCALL;
FUNCTION FIFO_SIZE(VAR FI:tFIFO):DWORD; STDCALL;
FUNCTION FIFO_FREE(VAR FI:tFIFO):DWORD; STDCALL;
PROCEDURE FIFO_WR(VAR FI:tFIFO; B:BYTE); STDCALL;
FUNCTION FIFO_RD(VAR FI:tFIFO):WORD; STDCALL;
FUNCTION FIFO_RDOFS(VAR FI:tFIFO; OFS:DWORD):WORD; STDCALL;
PROCEDURE FIFO_WROFS(VAR FI:tFIFO; OFS:DWORD; B:BYTE); STDCALL;
PROCEDURE FIFO_FLUSH(VAR FI:tFIFO; SIZE:DWORD=$FFFFFFFF); STDCALL;
FUNCTION FIFO_RD_BLOCK_SIZE(VAR FI:tFIFO; VAR BUF:POINTER; MAXSIZE:DWORD):DWORD;
FUNCTION FIFO_WR_GET_PTR_BLOCK_SIZE(VAR FI:tFIFO; VAR BUF:POINTER; MAXSIZE:DWORD=$FFFFFFFF):DWORD;
PROCEDURE FIFO_WR_ADD_SIZE(VAR FI:tFIFO; SIZE:DWORD);
FUNCTION FIFO_CLOSE(VAR FI:tFIFO):BOOLEAN; STDCALL;



IMPLEMENTATION
VAR IDCRC:tCRC;


FUNCTION CopyBinToString(VAR _FR;SIZ:DWORD):ShortString; STDCALL;
BEGIN
    SetLength(RESULT,SIZ);
    MOVE (_FR,RESULT[1],SIZ);
END;

FUNCTION CopyDWordToString(_FR:DWORD):ShortString; STDCALL;
BEGIN
    RESULT:=CopyBinToString(_FR,4);
END;
FUNCTION CopyWordToString(_FR:WORD):ShortString; STDCALL;
BEGIN
    RESULT:=CopyBinToString(_FR,2);
END;


FUNCTION FIFO_ID_STR(VAR FI:tFIFO):ShortString;
VAR D,CRC:DWORD;
    S:ShortString;
BEGIN
      D:=DWORD(@FI);
      S:=CopyDWordToString(D);
//      CRC:=CRC_BUF(IDCRC, D, 4);
      CRC:=CRC_STR(IDCRC, S);
      RESULT:=robFIFO_ID_STR + CopyDWordToString(CRC);
END;

FUNCTION FIFO_MASK_SIZE(SIZE:DWORD):DWORD; STDCALL;
VAR N:LONGINT;
BEGIN
      RESULT:=SIZE-1;
      FOR N:=0 TO 31 DO RESULT:=RESULT OR (RESULT SHR 1);
      INC(RESULT);

END;

//VAR SUPBUF:ARRAY[0..1024*1024*32] OF BYTE;
//    SUPBUP:DWORD=0;

FUNCTION FIFO_OPEN(VAR FI:tFIFO; SIZE:DWORD):BOOLEAN; STDCALL;
BEGIN
      IF FI.ID<>FIFO_ID_STR(FI) THEN BEGIN
       FI.WR:=0;
       FI.RD:=0;
       FI.SIZE:=FIFO_MASK_SIZE(SIZE);
       FI.MASK:=FI.SIZE-1;
       FI.DAT:=GetMemory(FI.SIZE);
//       FI.DAT:=@SUPBUF[SUPBUP];
//       INC(SUPBUP,FI.SIZE);
       FI.ID:=FIFO_ID_STR(FI);
       FI.FLAG:=0;
       RESULT:=TRUE;
      END ELSE BEGIN
       RESULT:=FALSE;
      END;
END;

FUNCTION FIFO_SIZE(VAR FI:tFIFO):DWORD; STDCALL;
BEGIN
      RESULT:=(FI.WR-FI.RD) AND FI.MASK;
END;

FUNCTION FIFO_FREE(VAR FI:tFIFO):DWORD; STDCALL;
BEGIN
      RESULT:=FI.SIZE-FIFO_SIZE(FI);
END;

PROCEDURE FIFO_WR(VAR FI:tFIFO; B:BYTE); STDCALL;
BEGIN
      IF FIFO_FREE(FI)>1 THEN BEGIN
       PByte(DWORD(FI.DAT)+FI.WR)^:=B;
       FI.WR:=(FI.WR+1) AND FI.MASK;
      END ELSE FI.FLAG:=FI.FLAG OR robFIFO_FLAG_OVERFLOW;
END;

FUNCTION FIFO_RD(VAR FI:tFIFO):WORD; STDCALL;
BEGIN
      IF FIFO_SIZE(FI)<>0 THEN BEGIN
       RESULT:=PByte(DWORD(FI.DAT)+FI.RD)^;
       FI.RD:=(FI.RD+1) AND FI.MASK;
      END ELSE RESULT:=$FFFF;
END;

FUNCTION FIFO_RDOFS(VAR FI:tFIFO; OFS:DWORD):WORD; STDCALL;
VAR FISI:DWORD;
BEGIN
      IF FIFO_SIZE(FI)>OFS THEN BEGIN
       RESULT:=PByte(DWORD(FI.DAT)+((FI.RD+OFS) AND FI.MASK))^;
      END ELSE RESULT:=$FFFF;
END;

PROCEDURE FIFO_WROFS(VAR FI:tFIFO; OFS:DWORD; B:BYTE); STDCALL;
VAR FISI:DWORD;
BEGIN
      IF FIFO_SIZE(FI)>OFS THEN BEGIN
       PByte(DWORD(FI.DAT)+((FI.RD+OFS) AND FI.MASK))^:=B;
      END;
END;

FUNCTION FIFO_RD_BLOCK_SIZE(VAR FI:tFIFO; VAR BUF:POINTER; MAXSIZE:DWORD):DWORD;
VAR SIZI:DWORD;
BEGIN
      SIZI:=FIFO_SIZE(FI);
      IF MAXSIZE>SIZI THEN MAXSIZE:=SIZI;
      IF (FI.RD+MAXSIZE)>FI.SIZE THEN MAXSIZE:=FI.SIZE-FI.RD;
      BUF:=POINTER(DWORD(FI.DAT)+FI.RD);
      RESULT:=MAXSIZE;
END;

FUNCTION FIFO_WR_GET_PTR_BLOCK_SIZE(VAR FI:tFIFO; VAR BUF:POINTER; MAXSIZE:DWORD=$FFFFFFFF):DWORD;
VAR SIZI:DWORD;
BEGIN
      SIZI:=FIFO_FREE(FI);
      IF MAXSIZE>SIZI THEN MAXSIZE:=SIZI;
      IF (FI.WR+MAXSIZE)>FI.SIZE THEN MAXSIZE:=FI.SIZE-FI.WR;
      BUF:=POINTER(DWORD(FI.DAT)+FI.WR);
      RESULT:=MAXSIZE;
END;

PROCEDURE FIFO_WR_ADD_SIZE(VAR FI:tFIFO; SIZE:DWORD);
BEGIN
      FI.WR:=(FI.WR+SIZE) AND FI.MASK;
END;

PROCEDURE FIFO_FLUSH(VAR FI:tFIFO; SIZE:DWORD=$FFFFFFFF); STDCALL;
VAR D:DWORD;
BEGIN
      D:=FIFO_SIZE(FI);
      IF D>SIZE THEN D:=SIZE;
      FI.RD:=(FI.RD+D) AND FI.MASK;
END;

FUNCTION FIFO_CLOSE(VAR FI:tFIFO):BOOLEAN; STDCALL;
BEGIN
      IF FI.ID=FIFO_ID_STR(FI) THEN BEGIN
       FreeMem(FI.DAT,FI.SIZE);
//       DEC(SUPBUP,FI.SIZE);
       FI.ID:='';
       FI.DAT:=NIL;
       RESULT:=TRUE;
      END ELSE BEGIN
       RESULT:=FALSE;
      END;
END;







BEGIN
      CRC_OPEN(IDCRC, $04C11DB7, CRC_MODE_32 OR CRC_REVERT);
END.
